#include "gameai.h"
#include "gamelogic.h"
#include "../../game/state.h"
#include "../../game/game.h"
#include "../../utils/timer.h"
#include <stdlib.h>

// Tile data used by the AI algorithm
struct AITiles {
    Vec2 tiles[MAX_GRID_WIDTH*MAX_GRID_HEIGHT]; //Every valid tile
    int tileCount;
    Vec2 notAvoidTiles[MAX_GRID_WIDTH*MAX_GRID_HEIGHT]; //Every tile that doesn't have to be avoided by AI (difficulty 2+)
    int naTileCount;
    Vec2 advTiles[MAX_GRID_WIDTH*MAX_GRID_HEIGHT]; //Every tile where the AI has a possible advantage over other players (difficulty 3)
    int advTileCount;
    Vec2 specTiles[MAX_GRID_WIDTH*MAX_GRID_HEIGHT]; //Every tile the AI should focus on the most (difficulty 2+)
    int specTileCount;
    Vec2 cornerTiles[4]; //Every corner tile the AI should focus on the most (difficulty 3)
    int cornerTileCount;

    Vec2* primaryTiles; //Tiles chosen by the AI with highest priority (can be either cornerTiles, specTiles or advTiles - in that order)
    int* primaryTileCount;
    Vec2* secondaryTiles; //Tiles chosen by the AI if there are no primary tiles (can be either notAvoidTiles or tiles - in that order)
    int* secondaryTileCount;
};

// AI Move Delay in milliseconds
#define AIDELAY 300

// Timer for AI movement delays
static KTimer* aiTimer = NULL;

// Array with positions diagonally neighboring with corner tiles (non-corner tiles are unused)
static Vec2 cornerCheckTab[MAX_GRID_WIDTH][MAX_GRID_HEIGHT];

bool aiPlayer[4];

int aiDifficulty[4];

/// @brief Checks if tile on a given position belongs to another player
/// @param x Tile X position
/// @param y Tile Y position
/// @return true if tile belongs to another player, false otherwise
static bool aiIsTileEnemy(int x, int y)
{
    int playerNum = logicData->tiles[x][y].playerNum;
    return (playerNum != NOPLAYER && playerNum != logicData->curPlayer);
}

/// @brief Get the amount of corners the current player has atoms on
/// @param max_x Max valid X position (width-1)
/// @param max_y Max valid Y position (height-1)
/// @return The amount of corners the current player has atoms on
static int aiGetCorners(int max_x, int max_y)
{
    int cornerCount = 0;
    if(logicData->tiles[0][0].playerNum == logicData->curPlayer)
        cornerCount++;
    if(logicData->tiles[max_x][0].playerNum == logicData->curPlayer)
        cornerCount++;
    if(logicData->tiles[0][max_y].playerNum == logicData->curPlayer)
        cornerCount++;
    if(logicData->tiles[max_x][max_y].playerNum == logicData->curPlayer)
        cornerCount++;
    return cornerCount;
}

/// @brief Checks if there are any atoms nearby
/// @param nearbyTiles Array of nearby tiles generated by getNearbyTiles
/// @param nearbyTileCount Amount of nearby tiles
/// @return true if there are atoms, false if not
static bool aiAtomsNearby(Vec2* nearbyTiles, int nearbyTileCount)
{
    for(int i=0; i<nearbyTileCount; i++)
    {
        int x = nearbyTiles[i].x;
        int y = nearbyTiles[i].y;
        if(logicData->tiles[x][y].atomCount > 0)
            return true;
    }
    return false;
}

/// @brief Checks if player has any atom advantage over another player on this tile
/// @param nearbyTiles Array of nearby tiles generated by getNearbyTiles
/// @param nearbyTileCount Amount of nearby tiles
/// @param patoms Difference between current atom count and critical amount
/// @return true if there are's an advantage, false if not
static bool aiCheckAdvantage(Vec2* nearbyTiles, int nearbyTileCount, int patoms)
{
    for(int i=0; i<nearbyTileCount; i++)
    {
        int x = nearbyTiles[i].x;
        int y = nearbyTiles[i].y;
        if(aiIsTileEnemy(x,y) && (patoms >= logicData->tiles[x][y].atomCount-logicData->critGrid[x][y]))
            return true;
    }
    return false;
}

/// @brief Check if enemy or the current player has an undefended corner (1 atom on every side near the corner and no 2 atom tile diagonally from the corner)
/// @param basex Checked corner tile X position
/// @param basey Checked corner tile Y position
/// @param nearbyTiles Array of nearby tiles generated by getNearbyTiles
/// @param nearbyTileCount Amount of nearby tiles
/// @return True if check succeeded, false if not
static bool aiCornerCheck(int basex, int basey, Vec2* nearbyTiles, int nearbyTileCount)
{
    if(logicData->critGrid[basex][basey] > 2)
        return false;

    int ccval = 0;
    int patoms = -2;
    for(int i=0; i<nearbyTileCount; i++)
    {
        int x = nearbyTiles[i].x;
        int y = nearbyTiles[i].y;
        struct KATile* curTile = &logicData->tiles[x][y];
        if(curTile->playerNum != NOPLAYER && patoms >= curTile->atomCount-logicData->critGrid[x][y])
            ccval++;
    }
    int cposx = cornerCheckTab[basex][basey].x;
    int cposy = cornerCheckTab[basex][basey].y;
    if(aiIsTileEnemy(cposx,cposy) && (logicData->tiles[basex][basey].atomCount == logicData->tiles[cposx][cposy].atomCount-2))
        return false;
    return (ccval >= 2);
}

/// @brief Check if any nearby tiles are 1 atom away from exploding
/// @param nearbyTiles Array of nearby tiles generated by getNearbyTiles
/// @param nearbyTileCount Amount of nearby tiles
/// @return True if the check succeeded, false if not
static bool aiCheckPreCrit(Vec2* nearbyTiles, int nearbyTileCount)
{
    for(int i=0; i<nearbyTileCount; i++)
    {
        int x = nearbyTiles[i].x;
        int y = nearbyTiles[i].y;
        if(aiIsTileEnemy(x,y) && (logicData->tiles[x][y].atomCount >= logicData->critGrid[x][y]-1))
            return true;
    }
    return false;
}

/// @brief Get an array of nearby tile positions
/// @param x Base tile X position
/// @param y Base tile Y position
/// @param _nearbyTiles Pointer to an array to write the positions to
/// @return Amount of nearby tiles
static int getNearbyTiles(int x, int y, Vec2 (*_nearbyTiles)[4])
{
    Vec2* nearbyTiles = *_nearbyTiles;
    int nearbyTileCount = 0;
    if(y > 0)
        nearbyTiles[nearbyTileCount++] = (Vec2){x,y-1};
    if(y < logicData->gridHeight-1)
        nearbyTiles[nearbyTileCount++] = (Vec2){x,y+1};
    if(x > 0)
        nearbyTiles[nearbyTileCount++] = (Vec2){x-1,y};
    if(x < logicData->gridWidth-1)
        nearbyTiles[nearbyTileCount++] = (Vec2){x+1,y};
    return nearbyTileCount;
}

/// @brief Run the AI algorithm and give the possible tiles for AI to place atom on
/// @param difficulty AI difficulty for current player
/// @param tiles AITiles struct used by the function, contains the possible move tiles in primaryTiles and secondaryTiles variables
static void aiGetSpecialTiles(int difficulty, struct AITiles* tiles)
{
    tiles->primaryTiles = tiles->specTiles;
    tiles->primaryTileCount = &tiles->specTileCount;
    tiles->secondaryTiles = tiles->tiles;
    tiles->secondaryTileCount = &tiles->tileCount;

    bool wasSpCorner = false;
    bool wasAdvCorner = false;
    int gridWidth = logicData->gridWidth;
    int gridHeight = logicData->gridHeight;
    int cornerCount = aiGetCorners(gridWidth-1, gridHeight-1);
    for(int x=0; x<gridWidth; x++)
    {
        for(int y=0; y<gridHeight; y++)
        {
            struct KATile* curTile = &logicData->tiles[x][y];
            Vec2 curPos = {x,y};
            if(curTile->playerNum == logicData->curPlayer || curTile->playerNum == NOPLAYER)
            {
                Vec2 nearbyTiles[4];
                int nearbyTileCount = getNearbyTiles(x,y,&nearbyTiles);
                int curCritAmount = logicData->critGrid[x][y];
                bool isSpTile = false;
                bool tileAvoided = false;
                tiles->tiles[tiles->tileCount++] = curPos;
                tiles->notAvoidTiles[tiles->naTileCount++] = curPos;
                if(difficulty == 2)
                {
                    if(aiCheckPreCrit(nearbyTiles,nearbyTileCount))
                    {
                        if(curTile->atomCount == (curCritAmount - 1))
                        {
                            tiles->specTiles[tiles->specTileCount++] = curPos;
                            isSpTile = true;
                        }
                        else
                        {
                            tiles->naTileCount--;
                            tileAvoided = true;
                        }
                    }
                }
                else if(difficulty == 3)
                {
                    bool isCorner = ((x == 0 || x == gridWidth-1) && (y == 0 || y == gridHeight-1));
                    if(isCorner && curTile->atomCount == 1 && !aiAtomsNearby(nearbyTiles,nearbyTileCount))
                    {
                        tiles->naTileCount--;
                        tileAvoided = true;
                    }
                    else if(aiCheckPreCrit(nearbyTiles,nearbyTileCount))
                    {
                        if(curTile->atomCount == (curCritAmount - 1))
                        {
                            tiles->specTiles[tiles->specTileCount++] = curPos;
                            isSpTile = true;
                        }
                        else
                        {
                            tiles->naTileCount--;
                            tileAvoided = true;
                        }
                    }
                    bool isAdvantage = false;
                    if(!isSpTile)
                        isAdvantage = aiCheckAdvantage(nearbyTiles, nearbyTileCount, curTile->atomCount-curCritAmount);
                    if(!tileAvoided && isCorner && (cornerCount == 0 || aiCornerCheck(x,y,nearbyTiles,nearbyTileCount)))
                    {
                        if(wasSpCorner && isSpTile)
                        {
                            tiles->cornerTiles[tiles->cornerTileCount++] = curPos;
                        }
                        else if(wasAdvCorner)
                        {
                            if(isSpTile)
                            {
                                tiles->cornerTileCount = 0;
                                wasSpCorner = true;
                            }
                            tiles->cornerTiles[tiles->cornerTileCount++] = curPos;
                        }
                        else
                        {
                            if(isSpTile)
                            {
                                tiles->cornerTileCount = 0;
                                wasSpCorner = true;
                            }
                            else if(isAdvantage)
                            {
                                tiles->cornerTileCount = 0;
                                wasAdvCorner = true;
                            }

                            if(curTile->atomCount == 0 || isSpTile || isAdvantage)
                                tiles->cornerTiles[tiles->cornerTileCount++] = curPos;
                        }
                    }
                    else if(isAdvantage && !isCorner && !tileAvoided)
                    {
                        tiles->advTiles[tiles->advTileCount++] = curPos;
                    }
                }
            }
        }
    }
    if(tiles->cornerTileCount > 0)
    {
        tiles->primaryTiles = tiles->cornerTiles;
        tiles->primaryTileCount = &tiles->cornerTileCount;
    }
    else if(tiles->specTileCount == 0 && tiles->advTileCount > 0)
    {
        tiles->primaryTiles = tiles->advTiles;
        tiles->primaryTileCount = &tiles->advTileCount;
    }

    if(tiles->naTileCount > 0)
    {
        tiles->secondaryTiles = tiles->notAvoidTiles;
        tiles->secondaryTileCount = &tiles->naTileCount;
    }
}

// Runs the AI algorithm and clicks a random tile from the AI algorithm recommended tiles
static void aiThinker(void)
{
    Vec2 selectedTile = (Vec2){-1,-1};
    if(aiDifficulty[logicData->curPlayer] <= 3)
    {
        struct AITiles* tiles = calloc(1,sizeof(struct AITiles));
        aiGetSpecialTiles(aiDifficulty[logicData->curPlayer],tiles);
        int spTileCount = *tiles->primaryTileCount;
        int tileCount = *tiles->secondaryTileCount;
        if(spTileCount > 0)
            selectedTile = tiles->primaryTiles[rand() % spTileCount];
        else if(tileCount > 0)
            selectedTile = tiles->secondaryTiles[rand() % tileCount];
        free(tiles);
    }
    else
    {
        game_errorMsg("Incorrect AI difficulty - %d",aiDifficulty[logicData->curPlayer]);
        return;
    }

    if(selectedTile.x == -1)
    {
        game_errorMsg("No Available AI Tiles for player %d",logicData->curPlayer);
        return;
    }
    gamelogic_clickedTile(selectedTile.x, selectedTile.y, true);
}

void ai_Init(void)
{
    int gridw = logicData->gridWidth;
    int gridh = logicData->gridHeight;
    if(!aiTimer)
        aiTimer = ktimer_create();
    memset(cornerCheckTab, 0, sizeof(cornerCheckTab));
    cornerCheckTab[0][0] = (Vec2){1,1};
    cornerCheckTab[0][gridh-1] = (Vec2){1,gridh-2};
    cornerCheckTab[gridw-1][0] = (Vec2){gridw-2,1};
    cornerCheckTab[gridw-1][gridh-1] = (Vec2){gridw-2,gridh-2};
}

void ai_ResetTime(void)
{
    ktimer_setTimeMillis(aiTimer, 0);
}

void ai_TryMove(void)
{
    if(ktimer_getTimeMillis(aiTimer) >= AIDELAY)
        aiThinker();
}
